<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/services/video-recorder.js - ember-lookit-frameplayer</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="https://yui-s.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-5">
            <div id="docs-sidebar" class="sidebar apidocs">
              <h2 style="display:inline;">
              <div>
                <img style="float:right; vertical-align:middle;" src="../assets/css/logo.png" height="70">
                <span>Lookit<br> component<br> docs</span>

                    <p>Version: latest <br>(v1.2.0)</p>
                    <select name="select_version" onchange="location = this.value;">
                        <option value="">--Select different version--</option>
                            <option value="releases/v1.2.0/">v1.2.0</option>
                    </select>
              </div>

              </h2>


              <div id="api-list">
                  <div id="api-tabview">
              
                    <div id="api-tabview-panel">
                        <h2 class="off-left">Collections</h2>
                        <ul id="api-modules" class="apis modules">
                            <li class="module-sidebar-exp-player"><a href="../modules/exp-player.html">exp-player</a></li>
                            <li class="module-sidebar-frames"><a href="../modules/frames.html">frames</a></li>
                            <li class="module-sidebar-mixins"><a href="../modules/mixins.html">mixins</a></li>
                            <li class="module-sidebar-randomizers"><a href="../modules/randomizers.html">randomizers</a></li>
                        </ul>
                        <h2 class="off-left">All elements</h2>
                              <div id="api-tabview-filter">
                      <input type="search" id="api-filter" placeholder="Type to filter">
                    </div>
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/Exp-frame-base.html">Exp-frame-base</a></li>
                            <li><a href="../classes/Exp-frame-select.html">Exp-frame-select</a></li>
                            <li><a href="../classes/Exp-lookit-calibration.html">Exp-lookit-calibration</a></li>
                            <li><a href="../classes/Exp-lookit-change-detection.html">Exp-lookit-change-detection</a></li>
                            <li><a href="../classes/Exp-lookit-composite-video-trial.html">Exp-lookit-composite-video-trial</a></li>
                            <li><a href="../classes/Exp-lookit-dialogue-page.html">Exp-lookit-dialogue-page</a></li>
                            <li><a href="../classes/Exp-lookit-exit-survey.html">Exp-lookit-exit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation.html">Exp-lookit-geometry-alternation</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation-open.html">Exp-lookit-geometry-alternation-open</a></li>
                            <li><a href="../classes/Exp-lookit-images-audio.html">Exp-lookit-images-audio</a></li>
                            <li><a href="../classes/Exp-lookit-instructions.html">Exp-lookit-instructions</a></li>
                            <li><a href="../classes/Exp-lookit-mood-questionnaire.html">Exp-lookit-mood-questionnaire</a></li>
                            <li><a href="../classes/Exp-lookit-observation.html">Exp-lookit-observation</a></li>
                            <li><a href="../classes/Exp-lookit-preferential-looking.html">Exp-lookit-preferential-looking</a></li>
                            <li><a href="../classes/Exp-lookit-stimuli-preview.html">Exp-lookit-stimuli-preview</a></li>
                            <li><a href="../classes/Exp-lookit-story-page.html">Exp-lookit-story-page</a></li>
                            <li><a href="../classes/Exp-lookit-survey.html">Exp-lookit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-text.html">Exp-lookit-text</a></li>
                            <li><a href="../classes/Exp-lookit-video.html">Exp-lookit-video</a></li>
                            <li><a href="../classes/Exp-lookit-video-assent.html">Exp-lookit-video-assent</a></li>
                            <li><a href="../classes/Exp-lookit-video-consent.html">Exp-lookit-video-consent</a></li>
                            <li><a href="../classes/Exp-lookit-webcam-display.html">Exp-lookit-webcam-display</a></li>
                            <li><a href="../classes/Exp-video-config.html">Exp-video-config</a></li>
                            <li><a href="../classes/Exp-video-config-quality.html">Exp-video-config-quality</a></li>
                            <li><a href="../classes/Expand-assets.html">Expand-assets</a></li>
                            <li><a href="../classes/Full-screen.html">Full-screen</a></li>
                            <li><a href="../classes/Media-reload.html">Media-reload</a></li>
                            <li><a href="../classes/Permute.html">Permute</a></li>
                            <li><a href="../classes/Random-parameter-set.html">Random-parameter-set</a></li>
                            <li><a href="../classes/Select.html">Select</a></li>
                            <li><a href="../classes/Session-record.html">Session-record</a></li>
                            <li><a href="../classes/Video-record.html">Video-record</a></li>
                            <li><a href="../classes/video-recorder.html">video-recorder</a></li>
                        </ul>
                    </div>
              
                  </div>
              </div>
            </div>
        </div>
        <div class="yui3-u-4-5">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/services/video-recorder.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;

/* OMIT *
 * @module exp-player
 * @submodule services
 */

let {
    $,
    RSVP
} = Ember;

var LOOKIT_PREFERRED_DEVICES = {
    &#x27;cam&#x27;: null,
    &#x27;mic&#x27;: null
};

// Deal with Firefox issue where, after selecting camera/mic to share and saying to
// &#x27;remember&#x27; settings, the default cam/mic are used each time getUserMedia is called.
// This does NOT fix persisting selections across multiple Lookit sessions, but will
// persist it through the session (one page load). (To forcibly fix selection, can
// revoke &amp; refresh page).
// Override getUserMedia function to insert our preference on camera and mic, and to set
// that preference the first time getUserMedia is called successfully. We do this rather than
// editing https://cdn.addpipe.com/2.0/pipe.js and hosting our own copy so we don&#x27;t have to
// maintain across changes to Pipe.
// Only override newer navigator.mediaDevices.getUserMedia rather than also
// navigator.getUserMedia, as the latter will only be used by Pipe if the newer one is not
// available, in which case probably bigger problems than this one.
navigator.mediaDevices.getUserMedia = (function(origGetUserMedia) {
    return function() {
        // Add preferred mic and camera, if already stored, to any other constraints being
        // passed to getUserMedia
        var constraints = arguments[0];
        if (constraints.hasOwnProperty(&#x27;audio&#x27;) &amp;&amp; LOOKIT_PREFERRED_DEVICES.mic) {
            constraints.audio.deviceId = LOOKIT_PREFERRED_DEVICES.mic;
        }
        if (constraints.hasOwnProperty(&#x27;video&#x27;) &amp;&amp; LOOKIT_PREFERRED_DEVICES.cam) {
            constraints.video.deviceId = LOOKIT_PREFERRED_DEVICES.cam;
        }
        return origGetUserMedia.apply(this, arguments).then(function(stream) {
            // Set the preferred cam/mic IDs the first time we get a stream
            try {
                var audioTracks = stream.getAudioTracks();
                var videoTracks = stream.getVideoTracks();
                if (!LOOKIT_PREFERRED_DEVICES.mic &amp;&amp; audioTracks) {
                    var thisAudioLabel = audioTracks[0].label;
                    navigator.mediaDevices.enumerateDevices()
                        .then(function(devices) {
                            devices.forEach(function(device) {
                                if (device.kind == &#x27;audioinput&#x27; &amp;&amp; device.label == thisAudioLabel) {
                                    LOOKIT_PREFERRED_DEVICES.mic = device.deviceId;
                                }
                            });
                        });
                }
                if (!LOOKIT_PREFERRED_DEVICES.cam &amp;&amp; videoTracks) {
                    var thisVideoLabel = videoTracks[0].label;
                    navigator.mediaDevices.enumerateDevices()
                        .then(function(devices) {
                            devices.forEach(function(device) {
                                if (device.kind == &#x27;videoinput&#x27; &amp;&amp; device.label == thisVideoLabel) {
                                    LOOKIT_PREFERRED_DEVICES.cam = device.deviceId;
                                }
                            });
                        });
                }
            } catch (error) {
                console.error(&#x27;Error setting preferred mic/camera: &#x27; + error);
            }
            return stream;
        });
    };
})(navigator.mediaDevices.getUserMedia);

/**
 * An instance of a video recorder tied to or used by one specific page. A given experiment may use more than one
 *   video recorder depending on the number of video capture frames.
 * @class video-recorder
 */
const VideoRecorder = Ember.Object.extend({

    element: null,

    divId: &#x27;lookit-video-recorder&#x27;,
    recorderId: (new Date().getTime() + &#x27;&#x27;),
    pipeVideoName: &#x27;&#x27;,

    started: Ember.computed.alias(&#x27;_started&#x27;).readOnly(),
    hasCamAccess: false,
    nWebcams: Ember.computed.alias(&#x27;_nWebcams&#x27;).readOnly(), // number of webcams available for recording
    nMics: Ember.computed.alias(&#x27;_nMics&#x27;).readOnly(), // number of microphones available for recording
    recording: Ember.computed.alias(&#x27;_recording&#x27;).readOnly(),
    hasCreatedRecording: Ember.computed.alias(&#x27;_hasCreatedRecording&#x27;).readOnly(),
    connected: false,
    uploadTimeout: null, // timer counting from attempt to stop until we should just
    //resolve the stopPromise
    maxUploadTimeMs: 5000,

    _started: false,
    _camAccess: false,
    _recording: false,
    _recorderReady: false,
    _hasCreatedRecording: false,
    _nWebcams: 0,
    _nMics: 0,

    _recordPromise: null,
    _stopPromise: null,
    _isuploaded: false,

    recorder: null, // The actual recorder object, also stored in PipeSDK.recorders obj

    // List of webcam hooks that should be added to recorder
    // See https://addpipe.com/docs#javascript-events-api
    hooks: [&#x27;onRecordingStarted&#x27;,
        &#x27;onCamAccess&#x27;,
        &#x27;onReadyToRecord&#x27;,
        &#x27;onUploadDone&#x27;,
        &#x27;userHasCamMic&#x27;,
        &#x27;onConnectionStatus&#x27;,
        &#x27;onMicActivityLevel&#x27;,
        &#x27;btPlayPressed&#x27;,
        &#x27;btRecordPressed&#x27;,
        &#x27;btStopRecordingPressed&#x27;,
        &#x27;btPausePressed&#x27;,
        &#x27;onPlaybackComplete&#x27;,
        &#x27;onConnectionClosed&#x27;,
        &#x27;onSaveOk&#x27;
    ],

    minVolume: 1, // Volume required to pass mic check
    micChecked: false, // Has the microphone ever exceeded minVolume?

    /**
     * Install a recorder onto the page and optionally begin recording immediately.
     *
     * @method install
     * @param videoFilename desired filename for video (will be set after saving with Pipe name) [&#x27;&#x27;]
     * @param pipeKey Pipe account hash [&#x27;&#x27;]
     * @param pipeEnv which Pipe environment [1]
     * @param maxRecordingTime recording length limit in s [100000000]
     * @param autosave whether to autosave - 1 or 0 [1]
     * @param audioOnly whether to do audio only recording - 1 or 0 [0]
     * @return {Promise} Resolves when widget successfully installed and started
     */

    install(videoFilename = &#x27;&#x27;, pipeKey = &#x27;&#x27;, pipeEnv = 1, maxRecordingTime = 100000000, autosave = 1, audioOnly = 0) {

        let origDivId = this.get(&#x27;divId&#x27;);

        this.set(&#x27;divId&#x27;, &#x60;${this.get(&#x27;divId&#x27;)}-${this.get(&#x27;recorderId&#x27;)}&#x60;);

        var $element = $(this.get(&#x27;element&#x27;));

        let divId = this.get(&#x27;divId&#x27;);

        var $container = $(&#x27;&lt;div&gt;&#x27;, {
            id: &#x60;${divId}-container&#x60;,
            css: {
                height: &#x27;100%&#x27;
            }
        });
        this.set(&#x27;$container&#x27;, $container);
        $container.append($(&#x27;&lt;div&gt;&#x27;, {id: divId, class: origDivId}));
        $element.append($container);

        return new RSVP.Promise((resolve, reject) =&gt; { // eslint-disable-line no-unused-vars

            var pipeConfig = {
                qualityurl: &#x27;https://d3l7d0ho3mojk5.cloudfront.net/pipe/720p.xml&#x27;,
                showMenu: 0, // hide recording button menu
                sis: 1, // skip initial screen
                asv: autosave, // autosave recordings
                st: 0, // don&#x27;t show timer
                mv: 0, // don&#x27;t mirror video for display
                dpv: 1, // disable pre-recorded video on mobile
                ao: audioOnly, // not audio-only
                dup: 0, // don&#x27;t allow file uploads
                payload: videoFilename, // data used by webhook to rename video
                accountHash:  pipeKey,
                eid:  pipeEnv, // environment ID for pipe account
                mrt:  maxRecordingTime,
                size:  { // just display size when showing to user. We override css.
                    width: 320,
                    height: 240
                }
            };

            this.set(&#x27;_started&#x27;, true);
            var _this = this;
            PipeSDK.insert(divId, pipeConfig, function(myRecorderObject) {
                _this.set(&#x27;recorder&#x27;, PipeSDK.getRecorderById(divId));
                _this.get(&#x27;hooks&#x27;).forEach(hookName =&gt; {
                    // At the time the hook is actually called, look up the appropriate
                    // functions both from here and that might be added later.
                    myRecorderObject[hookName] = function(...args) {
                        if (_this.get(&#x27;_&#x27; + hookName)) { // &#x27;Native&#x27; hook defined here
                            _this[&#x27;_&#x27; + hookName].apply(_this, args);
                        }
                        if (_this.hasOwnProperty(hookName)) { // Some hook added later via &#x27;on&#x27;
                            _this[hookName].apply(_this, args);
                        }
                    };
                });
            });

            return resolve();

        });
    },

    /**
     * Start recording a video, and allow the state of the recording to be accessed for later usage
     *
     * @method record
     * @return {Promise}
     */
    record() {
        if (!this.get(&#x27;started&#x27;)) {
            throw new Error(&#x27;Must call start before record&#x27;);
        }
        let count = 0;
        var _this = this;
        this.set(&#x27;_isuploaded&#x27;, false);
        let id = window.setInterval(() =&gt; {
            if (++count &gt; 50) { // stop trying - failure (5s)
                if (_this.get(&#x27;onCamAccess&#x27;)) {
                    _this.get(&#x27;onCamAccess&#x27;).call(_this, false);
                }
                return window.clearInterval(id), _this.get(&#x27;_recordPromise&#x27;).reject();
            }
            if (!_this.get(&#x27;recorder&#x27;) || !(_this.get(&#x27;recorder&#x27;).record)) {
                return null;
            }
            _this.get(&#x27;recorder&#x27;).record();
            window.clearInterval(id); // stop trying - success
            return null;
        }, 100); // try every 100ms

        return new Ember.RSVP.Promise((resolve, reject) =&gt; {
            if (_this.get(&#x27;recording&#x27;)) {
                resolve(this);
            } else {
                _this.set(&#x27;_recordPromise&#x27;, {
                    resolve,
                    reject
                });
            }
        });
    },

    /**
     * Get a timestamp based on the current recording position. Useful to ensure that tracked timing events
     *  line up with the video.
     * @method getTime
     * @return {Date|null}
     */
    getTime() {
        let recorder = this.get(&#x27;recorder&#x27;);
        if (recorder &amp;&amp; recorder.getStreamTime) {
            return parseFloat(recorder.getStreamTime());
        }
        return null;
    },

    /**
     * Stop recording and save the video to the server
     * @method stop
     */
    stop(maxUploadTimeMs = 5000) {
        var recorder = this.get(&#x27;recorder&#x27;);
        if (recorder) {
            try {
                recorder.stopVideo();
            } catch (e) {
                console.log(&#x27;error stopping video&#x27;);
            }
        }
        this.set(&#x27;_recording&#x27;, false);

        var _this = this;
        var _stopPromise = new Ember.RSVP.Promise((resolve, reject) =&gt; {
            // If we don&#x27;t end up uploading within 5 seconds, call reject
            _this.set(&#x27;uploadTimeout&#x27;, window.setTimeout(function() {
                console.warn(&#x27;waiting for upload timed out&#x27;);
                window.clearTimeout(_this.get(&#x27;uploadTimeout&#x27;));
                reject();
            }, maxUploadTimeMs));
            if (_this.get(&#x27;_isuploaded&#x27;)) {
                window.clearTimeout(_this.get(&#x27;uploadTimeout&#x27;));
                resolve(_this);
            } else {
                _this.set(&#x27;_stopPromise&#x27;, {
                    resolve: resolve,
                    reject: reject
                });
            }
        });
        return _stopPromise;
    },

    /**
     * Destroy video recorder
     *
     * @method destroy
     */
    destroy() {
        console.log(&#x60;Destroying the videoRecorder: ${this.get(&#x27;divId&#x27;)}&#x60;);
        $(&#x60;#${this.get(&#x27;divId&#x27;)}-container&#x60;).remove();
        if (this.get(&#x27;recorder&#x27;) &amp;&amp; this.get(&#x27;recorder&#x27;).remove) {
            this.get(&#x27;recorder&#x27;).remove();
        }
        this.set(&#x27;_recording&#x27;, false);
    },

    on(hookName, func) {
        if (this.get(&#x27;hooks&#x27;).indexOf(hookName) === -1) {
            throw &#x60;Invalid event ${hookName}&#x60;;
        }
        this.set(hookName, func);
    },

    // Begin webcam hooks
    _onRecordingStarted(recorderId) { // eslint-disable-line no-unused-vars
        this.set(&#x27;_recording&#x27;, true);
        this.set(&#x27;_hasCreatedRecording&#x27;, true);
        this.set(&#x27;pipeVideoName&#x27;, this.get(&#x27;recorder&#x27;).getStreamName());
        if (this.get(&#x27;_recordPromise&#x27;)) {
            this.get(&#x27;_recordPromise&#x27;).resolve(this);
        }
    },

    // Once recording finishes uploading, resolve call to stop
    _onUploadDone(recorderId, streamName, streamDuration, audioCodec, videoCodec, fileType, audioOnly, location) { // eslint-disable-line no-unused-vars
        window.clearTimeout(this.get(&#x27;uploadTimeout&#x27;));
        this.set(&#x27;_isuploaded&#x27;, true);
        if (this.get(&#x27;_stopPromise&#x27;)) {
            console.log(&#x27;Upload completed for file: &#x27; + streamName);
            this.get(&#x27;_stopPromise&#x27;).resolve(this);
        }
    },

    _onCamAccess(recorderId, allowed) { // eslint-disable-line no-unused-vars
        console.log(&#x27;onCamAccess: &#x27; + recorderId);
        this.set(&#x27;hasCamAccess&#x27;, allowed);
    },

    _onReadyToRecord(recorderId, recorderType) { // eslint-disable-line no-unused-vars
        this.set(&#x27;_recorderReady&#x27;, true);
    },

    _userHasCamMic(recorderId, camNumber, micNumber) { // eslint-disable-line no-unused-vars
        this.set(&#x27;_nWebcams&#x27;, camNumber);
        this.set(&#x27;_nMics&#x27;, micNumber);
    },

    _onConnectionStatus(recorderId, status) { // eslint-disable-line no-unused-vars
        this.set(&#x27;connected&#x27;, status === &#x27;connected&#x27;);
    },

    _onMicActivityLevel(recorderId, currentActivityLevel) { // eslint-disable-line no-unused-vars
        if (currentActivityLevel &gt; this.get(&#x27;minVolume&#x27;)) {
            this.set(&#x27;micChecked&#x27;, true);
            // Remove the handler so we&#x27;re not running this every single mic sample from now on
            this.set(&#x27;_onMicActivityLevel&#x27;, null);
            // This would remove the handler from the actual recorder, but we might have
            // something added by a consuming frame via the &#x27;on&#x27; fn
            //this.get(&#x27;recorder&#x27;).onMicActivityLevel = function (recorderId, currentActivityLevel) {};
        }
    }

    // Additional hooks available:
    //  btRecordPressed = function (recorderId) {};
    //  btPlayPressed(recorderId)
    //  btStopRecordingPressed = function (recorderId) {};
    //  btPausePressed = function (recorderId) {};
    //  onPlaybackComplete = function (recorderId) {};
    //  onConnectionClosed = function (recorderId) {};
    //  onSaveOk = function (recorderId, streamName, streamDuration, cameraName, micName, audioCodec, videoCodec, filetype, videoId, audioOnly, location) {};

    // End webcam hooks
});

export default VideoRecorder;

export { LOOKIT_PREFERRED_DEVICES };

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
