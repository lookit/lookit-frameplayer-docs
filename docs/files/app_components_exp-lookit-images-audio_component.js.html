<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/components/exp-lookit-images-audio/component.js - ember-lookit-frameplayer</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="https://yui-s.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-5">
            <div id="docs-sidebar" class="sidebar apidocs">
              <h2 style="display:inline;">
              <div>
                <img style="float:right; vertical-align:middle;" src="../assets/css/logo.png" height="70">
                <span>Lookit<br> component<br> docs</span>

                    <p>Version: latest <br>(v1.2.0)</p>
                    <select name="select_version" onchange="location = this.value;">
                        <option value="">--Select different version--</option>
                            <option value="releases/v1.2.0/">v1.2.0</option>
                    </select>
              </div>

              </h2>


              <div id="api-list">
                  <div id="api-tabview">
              
                    <div id="api-tabview-panel">
                        <h2 class="off-left">Collections</h2>
                        <ul id="api-modules" class="apis modules">
                            <li class="module-sidebar-exp-player"><a href="../modules/exp-player.html">exp-player</a></li>
                            <li class="module-sidebar-frames"><a href="../modules/frames.html">frames</a></li>
                            <li class="module-sidebar-mixins"><a href="../modules/mixins.html">mixins</a></li>
                            <li class="module-sidebar-randomizers"><a href="../modules/randomizers.html">randomizers</a></li>
                        </ul>
                        <h2 class="off-left">All elements</h2>
                              <div id="api-tabview-filter">
                      <input type="search" id="api-filter" placeholder="Type to filter">
                    </div>
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/Exp-frame-base.html">Exp-frame-base</a></li>
                            <li><a href="../classes/Exp-frame-select.html">Exp-frame-select</a></li>
                            <li><a href="../classes/Exp-lookit-calibration.html">Exp-lookit-calibration</a></li>
                            <li><a href="../classes/Exp-lookit-change-detection.html">Exp-lookit-change-detection</a></li>
                            <li><a href="../classes/Exp-lookit-composite-video-trial.html">Exp-lookit-composite-video-trial</a></li>
                            <li><a href="../classes/Exp-lookit-dialogue-page.html">Exp-lookit-dialogue-page</a></li>
                            <li><a href="../classes/Exp-lookit-exit-survey.html">Exp-lookit-exit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation.html">Exp-lookit-geometry-alternation</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation-open.html">Exp-lookit-geometry-alternation-open</a></li>
                            <li><a href="../classes/Exp-lookit-images-audio.html">Exp-lookit-images-audio</a></li>
                            <li><a href="../classes/Exp-lookit-instructions.html">Exp-lookit-instructions</a></li>
                            <li><a href="../classes/Exp-lookit-mood-questionnaire.html">Exp-lookit-mood-questionnaire</a></li>
                            <li><a href="../classes/Exp-lookit-observation.html">Exp-lookit-observation</a></li>
                            <li><a href="../classes/Exp-lookit-preferential-looking.html">Exp-lookit-preferential-looking</a></li>
                            <li><a href="../classes/Exp-lookit-stimuli-preview.html">Exp-lookit-stimuli-preview</a></li>
                            <li><a href="../classes/Exp-lookit-story-page.html">Exp-lookit-story-page</a></li>
                            <li><a href="../classes/Exp-lookit-survey.html">Exp-lookit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-text.html">Exp-lookit-text</a></li>
                            <li><a href="../classes/Exp-lookit-video.html">Exp-lookit-video</a></li>
                            <li><a href="../classes/Exp-lookit-video-assent.html">Exp-lookit-video-assent</a></li>
                            <li><a href="../classes/Exp-lookit-video-consent.html">Exp-lookit-video-consent</a></li>
                            <li><a href="../classes/Exp-lookit-webcam-display.html">Exp-lookit-webcam-display</a></li>
                            <li><a href="../classes/Exp-video-config.html">Exp-video-config</a></li>
                            <li><a href="../classes/Exp-video-config-quality.html">Exp-video-config-quality</a></li>
                            <li><a href="../classes/Expand-assets.html">Expand-assets</a></li>
                            <li><a href="../classes/Full-screen.html">Full-screen</a></li>
                            <li><a href="../classes/Media-reload.html">Media-reload</a></li>
                            <li><a href="../classes/Permute.html">Permute</a></li>
                            <li><a href="../classes/Random-parameter-set.html">Random-parameter-set</a></li>
                            <li><a href="../classes/Select.html">Select</a></li>
                            <li><a href="../classes/Session-record.html">Session-record</a></li>
                            <li><a href="../classes/Video-record.html">Video-record</a></li>
                            <li><a href="../classes/video-recorder.html">video-recorder</a></li>
                        </ul>
                    </div>
              
                  </div>
              </div>
            </div>
        </div>
        <div class="yui3-u-4-5">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/components/exp-lookit-images-audio/component.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import layout from &#x27;./template&#x27;;
import ExpFrameBaseComponent from &#x27;../exp-frame-base/component&#x27;;
import FullScreen from &#x27;../../mixins/full-screen&#x27;;
import VideoRecord from &#x27;../../mixins/video-record&#x27;;
import ExpandAssets from &#x27;../../mixins/expand-assets&#x27;;
import { audioAssetOptions, imageAssetOptions } from &#x27;../../mixins/expand-assets&#x27;;
import isColor from &#x27;../../utils/is-color&#x27;;

let {
    $
} = Ember;


/**
 * @module exp-player
 * @submodule frames
 */

/**
 * Frame to display image(s) and play audio, with optional video recording. Options allow
 * customization for looking time, storybook, forced choice, and reaction time type trials,
 * including training versions where children (or parents) get feedback about their responses.
 *
 * This can be used in a variety of ways - for example:
 *
 * - Display an image for a set amount of time and measure looking time
 *
 * - Display two images for a set amount of time and play audio for a
 * looking-while-listening paradigm
 *
 * - Show a &quot;storybook page&quot; where you show images and play audio, having the parent/child
 * press &#x27;Next&#x27; to proceed. If desired,
 * images can appear and be highlighted at specific times
 * relative to audio. E.g., the audio might say &quot;This [image of Remy appears] is a boy
 * named Remy. Remy has a little sister [image of Zenna appears] named Zenna.
 * [Remy highlighted] Remy&#x27;s favorite food is brussel sprouts, but [Zenna highlighted]
 * Zenna&#x27;s favorite food is ice cream. [Remy and Zenna both highlighted] Remy and Zenna
 * both love tacos!&quot;
 *
 * - Play audio asking the child to choose between two images by pointing or answering
 * verbally. Show text for the parent about how to help and when to press Next.
 *
 * - Play audio asking the child to choose between two images, and require one of those
 * images to be clicked to proceed (see &quot;choiceRequired&quot; option).
 *
 * - Measure reaction time as the child is asked to choose a particular option on each trial
 * (e.g., a central cue image is shown first, then two options at a short delay; the child
 * clicks on the one that matches the cue in some way)
 *
 * - Provide audio and/or text feedback on the child&#x27;s (or parent&#x27;s) choice before proceeding,
 * either just to make the study a bit more interactive (&quot;Great job, you chose the color BLUE!&quot;)
 * or for initial training/familiarization to make sure they understand the task. Some
 * images can be marked as the &quot;correct&quot; answer and a correct answer required to proceed.
 * If you&#x27;d like to include some initial training questions before your test questions,
 * this is a great way to do it.
 *
 * In general, the images are displayed in a designated region of the screen with aspect
 * ratio 7:4 (1.75 times as wide as it is tall) to standardize display as much as possible
 * across different monitors. If you want to display things truly fullscreen, you can
 * use &#x60;autoProceed&#x60; and not provide &#x60;parentText&#x60; so there&#x27;s nothing at the bottom, and then
 * set &#x60;maximizeDisplay&#x60; to true.
 *
 * Webcam recording may be turned on or off; if on, stimuli are not displayed and audio is
 * not started until recording begins. (Using the frame-specific &#x60;isRecording&#x60; property
 * is good if you have a smallish number of test trials and prefer to have separate video
 * clips for each. For reaction time trials or many short trials, you will likely want
 * to use session recording instead - i.e. start the session recording before the first trial
 * and end on the last trial - to avoid the short delays related to starting/stopping the video.)
 *
 * This frame is displayed fullscreen, but is not paused or otherwise disabled if the
 * user leaves fullscreen. A button appears prompting the user to return to
 * fullscreen mode.
 *
 * Any number of images may be placed on the screen, and their position
 * specified. (Aspect ratio will be the same as the original image.)
 *
 * The examples below show a variety of usages, corresponding to those shown in the video.
 *
 * image-1: Single image displayed full-screen, maximizing area on monitor, for 8 seconds.
 *
 * image-2: Single image displayed at specified position, with &#x27;next&#x27; button to move on
 *
 * image-3: Image plus audio, auto-proceeding after audio completes and 4 seconds go by
 *
 * image-4: Image plus audio, with &#x27;next&#x27; button to move on
 *
 * image-5: Two images plus audio question asking child to point to one of the images,
 *   demonstrating different timing of image display &amp; highlighting of images during audio
 *
 * image-6: Three images with audio prompt, family has to click one of two to continue
 *
 * image-7: Three images with audio prompt, family has to click correct one to continue -
 *   audio feedback on incorrect answer
 *
 * image-8: Three images with audio prompt, family has to click correct one to continue -
 *   text feedback on incorrect answer
 *
 *

&#x60;&#x60;&#x60;json
 &quot;frames&quot;: {
    &quot;image-1&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;cats&quot;,
                &quot;src&quot;: &quot;two_cats.png&quot;,
                &quot;position&quot;: &quot;fill&quot;
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;autoProceed&quot;: true,
        &quot;doRecording&quot;: true,
        &quot;durationSeconds&quot;: 8,
        &quot;maximizeDisplay&quot;: true
    },
    &quot;image-2&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;cats&quot;,
                &quot;src&quot;: &quot;three_cats.JPG&quot;,
                &quot;top&quot;: 10,
                &quot;left&quot;: 30,
                &quot;width&quot;: 40
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;autoProceed&quot;: false,
        &quot;doRecording&quot;: true,
        &quot;parentTextBlock&quot;: {
            &quot;text&quot;: &quot;Some explanatory text for parents&quot;,
            &quot;title&quot;: &quot;For parents&quot;
        }
    },
    &quot;image-3&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;audio&quot;: &quot;wheresremy&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;remy&quot;,
                &quot;src&quot;: &quot;wheres_remy.jpg&quot;,
                &quot;position&quot;: &quot;fill&quot;
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;audioTypes&quot;: [
            &quot;mp3&quot;,
            &quot;ogg&quot;
        ],
        &quot;autoProceed&quot;: true,
        &quot;doRecording&quot;: false,
        &quot;durationSeconds&quot;: 4,
        &quot;parentTextBlock&quot;: {
            &quot;text&quot;: &quot;Some explanatory text for parents&quot;,
            &quot;title&quot;: &quot;For parents&quot;
        },
        &quot;showProgressBar&quot;: true
    },
    &quot;image-4&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;audio&quot;: &quot;peekaboo&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;remy&quot;,
                &quot;src&quot;: &quot;peekaboo_remy.jpg&quot;,
                &quot;position&quot;: &quot;fill&quot;
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;audioTypes&quot;: [
            &quot;mp3&quot;,
            &quot;ogg&quot;
        ],
        &quot;autoProceed&quot;: false,
        &quot;doRecording&quot;: false,
        &quot;parentTextBlock&quot;: {
            &quot;text&quot;: &quot;Some explanatory text for parents&quot;,
            &quot;title&quot;: &quot;For parents&quot;
        }
    },
    &quot;image-5&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;audio&quot;: &quot;remyzennaintro&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;remy&quot;,
                &quot;src&quot;: &quot;scared_remy.jpg&quot;,
                &quot;position&quot;: &quot;left&quot;
            },
            {
                &quot;id&quot;: &quot;zenna&quot;,
                &quot;src&quot;: &quot;love_zenna.jpg&quot;,
                &quot;position&quot;: &quot;right&quot;,
                &quot;displayDelayMs&quot;: 1500
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;highlights&quot;: [
            {
                &quot;range&quot;: [
                    0,
                    1.5
                ],
                &quot;imageId&quot;: &quot;remy&quot;
            },
            {
                &quot;range&quot;: [
                    1.5,
                    3
                ],
                &quot;imageId&quot;: &quot;zenna&quot;
            }
        ],
        &quot;autoProceed&quot;: false,
        &quot;doRecording&quot;: true,
        &quot;parentTextBlock&quot;: {
            &quot;text&quot;: &quot;Some explanatory text for parents&quot;,
            &quot;title&quot;: &quot;For parents&quot;
        }
    },
    &quot;image-6&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;audio&quot;: &quot;matchremy&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;cue&quot;,
                &quot;src&quot;: &quot;happy_remy.jpg&quot;,
                &quot;position&quot;: &quot;center&quot;,
                &quot;nonChoiceOption&quot;: true
            },
            {
                &quot;id&quot;: &quot;option1&quot;,
                &quot;src&quot;: &quot;happy_zenna.jpg&quot;,
                &quot;position&quot;: &quot;left&quot;,
                &quot;displayDelayMs&quot;: 2000
            },
            {
                &quot;id&quot;: &quot;option2&quot;,
                &quot;src&quot;: &quot;annoyed_zenna.jpg&quot;,
                &quot;position&quot;: &quot;right&quot;,
                &quot;displayDelayMs&quot;: 2000
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;autoProceed&quot;: false,
        &quot;doRecording&quot;: true,
        &quot;choiceRequired&quot;: true,
        &quot;parentTextBlock&quot;: {
            &quot;text&quot;: &quot;Some explanatory text for parents&quot;,
            &quot;title&quot;: &quot;For parents&quot;
        },
        &quot;canMakeChoiceBeforeAudioFinished&quot;: true
    },
    &quot;image-7&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;audio&quot;: &quot;matchzenna&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;cue&quot;,
                &quot;src&quot;: &quot;sad_zenna.jpg&quot;,
                &quot;position&quot;: &quot;center&quot;,
                &quot;nonChoiceOption&quot;: true
            },
            {
                &quot;id&quot;: &quot;option1&quot;,
                &quot;src&quot;: &quot;surprised_remy.jpg&quot;,
                &quot;position&quot;: &quot;left&quot;,
                &quot;feedbackAudio&quot;: &quot;negativefeedback&quot;,
                &quot;displayDelayMs&quot;: 3500
            },
            {
                &quot;id&quot;: &quot;option2&quot;,
                &quot;src&quot;: &quot;sad_remy.jpg&quot;,
                &quot;correct&quot;: true,
                &quot;position&quot;: &quot;right&quot;,
                &quot;displayDelayMs&quot;: 3500
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;autoProceed&quot;: false,
        &quot;doRecording&quot;: true,
        &quot;choiceRequired&quot;: true,
        &quot;parentTextBlock&quot;: {
            &quot;text&quot;: &quot;Some explanatory text for parents&quot;,
            &quot;title&quot;: &quot;For parents&quot;
        },
        &quot;correctChoiceRequired&quot;: true,
        &quot;canMakeChoiceBeforeAudioFinished&quot;: false
    },
    &quot;image-8&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-images-audio&quot;,
        &quot;audio&quot;: &quot;matchzenna&quot;,
        &quot;images&quot;: [
            {
                &quot;id&quot;: &quot;cue&quot;,
                &quot;src&quot;: &quot;sad_zenna.jpg&quot;,
                &quot;position&quot;: &quot;center&quot;,
                &quot;nonChoiceOption&quot;: true
            },
            {
                &quot;id&quot;: &quot;option1&quot;,
                &quot;src&quot;: &quot;surprised_remy.jpg&quot;,
                &quot;position&quot;: &quot;left&quot;,
                &quot;feedbackText&quot;: &quot;Try again! Remy looks surprised in that picture. Can you find the picture where he looks sad, like Zenna?&quot;,
                &quot;displayDelayMs&quot;: 3500
            },
            {
                &quot;id&quot;: &quot;option2&quot;,
                &quot;src&quot;: &quot;sad_remy.jpg&quot;,
                &quot;correct&quot;: true,
                &quot;position&quot;: &quot;right&quot;,
                &quot;feedbackText&quot;: &quot;Great job! Remy is sad in that picture, just like Zenna is sad.&quot;,
                &quot;displayDelayMs&quot;: 3500
            }
        ],
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;autoProceed&quot;: false,
        &quot;doRecording&quot;: true,
        &quot;choiceRequired&quot;: true,
        &quot;parentTextBlock&quot;: {
            &quot;text&quot;: &quot;Some explanatory text for parents&quot;,
            &quot;title&quot;: &quot;For parents&quot;
        },
        &quot;correctChoiceRequired&quot;: true,
        &quot;canMakeChoiceBeforeAudioFinished&quot;: false
    }
 }

 * &#x60;&#x60;&#x60;
 * @class Exp-lookit-images-audio
 * @extends Exp-frame-base
 * @uses Full-screen
 * @uses Video-record
 * @uses Expand-assets
 */


export default ExpFrameBaseComponent.extend(FullScreen, VideoRecord, ExpandAssets, {

    type: &#x27;exp-lookit-images-audio&#x27;,
    layout: layout,
    displayFullscreen: true, // force fullscreen for all uses of this component
    fullScreenElementId: &#x27;experiment-player&#x27;, // which element to send fullscreen
    fsButtonID: &#x27;fsButton&#x27;, // ID of button to go to fullscreen

    startedTrial: false, // whether we&#x27;ve started playing audio yet

    // Override setting in VideoRecord mixin - only use camera if doing recording
    doUseCamera: Ember.computed.alias(&#x27;doRecording&#x27;),
    startRecordingAutomatically: Ember.computed.alias(&#x27;doRecording&#x27;),

    pageTimer: null,
    progressTimer: null,
    nextButtonDisableTimer: null,
    showChoiceTimer: null,
    imageDisplayTimers: null,

    autoProceed: false,
    finishedAllAudio: false,
    minDurationAchieved: false,

    choiceRequired: false,
    correctChoiceRequired: false,
    correctImageSelected: false,
    canMakeChoice: true,
    showingFeedbackDialog: false,
    selectedImage: null,

    noParentText: false,

    assetsToExpand: {
        &#x27;audio&#x27;: [&#x27;audio&#x27;, &#x27;images/feedbackAudio&#x27;],
        &#x27;video&#x27;: [],
        &#x27;image&#x27;: [&#x27;images/src&#x27;]
    },

    frameSchemaProperties: {
        /**
         * Whether to do webcam recording (will wait for webcam
         * connection before starting audio or showing images if so)
         *
         * @property {Boolean} doRecording
         */
        doRecording: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether to do webcam recording (will wait for webcam connection before starting audio if so&#x27;
        },

        /**
         * Whether to proceed automatically when all conditions are met, vs. enabling
         * next button at that point. If true: the next, previous, and replay buttons are
         * hidden, and the frame auto-advances after ALL of the following happen
         * (a) the audio segment (if any) completes
         * (b) the durationSeconds (if any) is achieved
         * (c) a choice is made (if required)
         * (d) that choice is correct (if required)
         * (e) the choice audio (if any) completes
         * (f) the choice text (if any) is dismissed
         * If false: the next, previous, and replay buttons (as applicable) are displayed.
         * It becomes possible to press &#x27;next&#x27; only once the conditions above are met.
         *
         * @property {Boolean} autoProceed
         * @default false
         */
        autoProceed: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether to proceed automatically after audio (and hide replay/next buttons)&#x27;,
            default: false
        },

        /**
         * Minimum duration of frame in seconds. If set, then it will only
         * be possible to proceed to the next frame after both the audio completes AND
         * this duration is acheived.
         *
         * @property {Number} durationSeconds
         * @default 0
         */
        durationSeconds: {
            type: &#x27;number&#x27;,
            description: &#x27;Minimum duration of frame in seconds&#x27;,
            minimum: 0,
            default: 0
        },

        /**
         * [Only used if durationSeconds set] Whether to
         * show a progress bar based on durationSeconds in the parent text area.
         *
         * @property {Boolean} showProgressBar
         * @default false
         */
        showProgressBar: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether to show a progress bar based on durationSeconds&#x27;,
            default: false
        },

        /**
         * [Only used if not autoProceed] Whether to
         * show a previous button to allow the participant to go to the previous frame
         *
         * @property {Boolean} showPreviousButton
         * @default true
         */
        showPreviousButton: {
            type: &#x27;boolean&#x27;,
            default: true,
            description: &#x27;Whether to show a previous button (used only if showing Next button)&#x27;
        },

        /**
         * [Only used if not autoProceed AND if there is audio] Whether to
         * show a replay button to allow the participant to replay the audio
         *
         * @property {Boolean} showReplayButton
         * @default false
         */
        showReplayButton: {
            type: &#x27;boolean&#x27;,
            default: true,
            description: &#x27;Whether to show a replay button (used only if showing Next button)&#x27;
        },

        /**
         * Whether to have the image display area take up the whole screen if possible.
         * This will only apply if (a) there is no parent text and (b) there are no
         * control buttons (next, previous, replay) because the frame auto-proceeds.
         *
         * @property {Boolean} maximizeDisplay
         * @default false
         */
        maximizeDisplay: {
            type: &#x27;boolean&#x27;,
            default: false,
            description: &#x27;Whether to have the image display area take up the whole screen if possible&#x27;
        },

        /**
         * Audio file to play at the start of this frame.
         * This can either be an array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects, e.g.
         * listing equivalent .mp3 and .ogg files, or can be a single string &#x60;filename&#x60;
         * which will be expanded based on &#x60;baseDir&#x60; and &#x60;audioTypes&#x60; values (see &#x60;audioTypes&#x60;).
         *
         * @property {Object[]} audio
         * @default []
         *
         */
        audio: {
            anyOf: audioAssetOptions,
            description: &#x27;Audio to play as this frame begins&#x27;,
            default: []
        },
        /**
         * Text block to display to parent.  (Each field is optional)
         *
         * @property {Object} parentTextBlock
         *   @param {String} title title to display
         *   @param {String} text paragraph of text
         *   @param {Object} css object specifying any css properties
         *      to apply to this section, and their values - e.g.
         *      {&#x27;color&#x27;: &#x27;gray&#x27;, &#x27;font-size&#x27;: &#x27;large&#x27;}
         */
        parentTextBlock: {
            type: &#x27;object&#x27;,
            properties: {
                title: {
                    type: &#x27;string&#x27;
                },
                text: {
                    type: &#x27;string&#x27;
                },
                css: {
                    type: &#x27;object&#x27;,
                    default: {}
                }
            },
            default: {}
        },
        /**
         * Array of images to display and information about their placement. For each
         * image, you need to specify &#x60;src&#x60; (image name/URL) and placement (either by
         * providing left/width/top values, or by using a &#x60;position&#x60; preset).
         *
         * Everything else is optional! This is where you would say that an image should
         * be shown at a delay
         *
         * @property {Object[]} images
         *   @param {String} id unique ID for this image
         *   @param {String} src URL of image source. This can be a full
         *     URL, or relative to baseDir (see baseDir).
         *   @param {String} alt alt-text for image in case it doesn&#x27;t load and for
         *     screen readers
         *   @param {Number} left left margin, as percentage of story area width. If not provided,
         *     the image is centered horizontally.
         *   @param {Number} width image width, as percentage of story area width. Note:
         *     in general only provide one of width and height; the other will be adjusted to
         *     preserve the image aspect ratio.
         *   @param {Number} top top margin, as percentage of story area height. If not provided,
         *     the image is centered vertically.
         *   @param {Number} height image height, as percentage of story area height. Note:
         *     in general only provide one of width and height; the other will be adjusted to
         *     preserve the image aspect ratio.
         *   @param {String} position one of &#x27;left&#x27;, &#x27;center&#x27;, &#x27;right&#x27;, &#x27;fill&#x27; to use presets
         *     that place the image in approximately the left, center, or right third of
         *     the screen or to fill the screen as much as possible.
         *     This overrides left/width/top values if given.
         *   @param {Boolean} nonChoiceOption [Only used if &#x60;choiceRequired&#x60; is true]
         *     whether this should be treated as a non-clickable option (e.g., this is
         *     a picture of a girl, and the child needs to choose whether the girl has a
         *     DOG or a CAT)
         *   @param {Number} displayDelayMs Delay at which to show the image after trial
         *     start (timing will be relative to any audio or to start of trial if no
         *     audio). Optional; default is to show images immediately.
         *   @param {Object[]} feedbackAudio [Only used if &#x60;choiceRequired&#x60; is true]
         *      Audio to play upon clicking this image. This can either be an array of
         *     {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects, e.g. listing equivalent .mp3 and
         *     .ogg files, or can be a single string &#x60;filename&#x60; which will be expanded
         *     based on &#x60;baseDir&#x60; and &#x60;audioTypes&#x60; values (see &#x60;audioTypes&#x60;).
         *   @param {String} feedbackText [Only used if &#x60;choiceRequired&#x60; is true] Text
         *     to display in a dialogue window upon clicking the image.
         */
        images: {
            type: &#x27;array&#x27;,
            items: {
                type: &#x27;object&#x27;,
                properties: {
                    &#x27;id&#x27;: {
                        type: &#x27;string&#x27;
                    },
                    &#x27;src&#x27;: {
                        anyOf: imageAssetOptions
                    },
                    &#x27;alt&#x27;: {
                        type: &#x27;string&#x27;
                    },
                    &#x27;left&#x27;: {
                        type: &#x27;number&#x27;
                    },
                    &#x27;width&#x27;: {
                        type: &#x27;number&#x27;
                    },
                    &#x27;top&#x27;: {
                        type: &#x27;number&#x27;
                    },
                    &#x27;height&#x27;: {
                        type: &#x27;number&#x27;
                    },
                    &#x27;position&#x27;: {
                        type: &#x27;string&#x27;,
                        enum: [&#x27;left&#x27;, &#x27;center&#x27;, &#x27;right&#x27;, &#x27;fill&#x27;]
                    },
                    &#x27;nonChoiceOption&#x27;: {
                        type: &#x27;boolean&#x27;
                    },
                    &#x27;displayDelayMs&#x27;: {
                        type: &#x27;number&#x27;,
                        minimum: 0
                    },
                    &#x27;correct&#x27;: {
                        type: &#x27;boolean&#x27;
                    },
                    &#x27;feedbackAudio&#x27;: {
                        anyOf: audioAssetOptions
                    },
                    &#x27;feedbackText&#x27;: {
                        type: &#x27;string&#x27;
                    }
                }
            }
        },
        /**
         * Color of background. See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
         * for acceptable syntax: can use color names (&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;green&#x27;, etc.), or
         * rgb hex values (e.g. &#x27;#800080&#x27; - include the &#x27;#&#x27;)
         *
         * @property {String} backgroundColor
         * @default &#x27;black&#x27;
         */
        backgroundColor: {
            type: &#x27;string&#x27;,
            description: &#x27;Color of background&#x27;,
            default: &#x27;black&#x27;
        },
        /**
         * Color of area where images are shown, if different from overall background.
         * Defaults to backgroundColor if one is provided. See
         * https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
         * for acceptable syntax: can use color names (&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;green&#x27;, etc.), or
         * rgb hex values (e.g. &#x27;#800080&#x27; - include the &#x27;#&#x27;)
         *
         * @property {String} pageColor
         * @default &#x27;white&#x27;
         */
        pageColor: {
            type: &#x27;string&#x27;,
            description: &#x27;Color of image area&#x27;,
            default: &#x27;white&#x27;
        },
        /**
         * Whether this is a frame where the user needs to click to select one of the
         * images before proceeding.
         *
         * @property {Boolean} choiceRequired
         * @default false
         */
        choiceRequired: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether this is a frame where the user needs to click to select one of the images before proceeding&#x27;,
            default: false
        },
        /**
         * [Only used if &#x60;choiceRequired&#x60; is true] Whether the participant has to select
         * one of the *correct* images before proceeding.
         *
         * @property {Boolean} correctChoiceRequired
         * @default false
         */
        correctChoiceRequired: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether this is a frame where the user needs to click a correct image before proceeding&#x27;,
            default: false
        },
        /**
         * Whether the participant can make a choice before audio finishes. (Only relevant
         * if &#x60;choiceRequired&#x60; is true.)
         *
         * @property {Boolean} canMakeChoiceBeforeAudioFinished
         * @default false
         */
        canMakeChoiceBeforeAudioFinished: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether the participant can select an option before audio finishes&#x27;,
            default: false
        },
        /**
         * Array representing times when particular images should be highlighted. Each
         * element of the array should be of the form {&#x27;range&#x27;: [3.64, 7.83], &#x27;imageId&#x27;: &#x27;myImageId&#x27;}.
         * The two &#x60;range&#x60; values are the start and end times of the highlight in seconds,
         * relative to the audio played. The &#x60;imageId&#x60; corresponds to the &#x60;id&#x60; of an
         * element of &#x60;images&#x60;.
         *
         * Highlights can overlap in time. Any that go longer than the audio will just
         * be ignored/cut off.
         *
         * One strategy for generating a bunch of highlights for a longer story is to
         * annotate using Audacity and export the labels to get the range values.
         *
         * @property {Object[]} highlights
         *   @param {Array} range [startTimeInSeconds, endTimeInSeconds], e.g. [3.64, 7.83]
         *   @param {String} imageId ID of the image to highlight, corresponding to the &#x60;id&#x60; field of the element of &#x60;images&#x60; to highlight
         */
        highlights: {
            type: &#x27;array&#x27;,
            items: {
                type: &#x27;object&#x27;,
                properties: {
                    &#x27;range&#x27;: {
                        type: &#x27;array&#x27;,
                        items: {
                            type: &#x27;number&#x27;,
                            minimum: 0
                        }
                    },
                    &#x27;imageId&#x27;: {
                        &#x27;type&#x27;: &#x27;string&#x27;
                    }
                }
            },
            default: []
        }
    },

    meta: {
        name: &#x27;ExpLookitImagesAudio&#x27;,
        description: &#x27;Frame to display images and/or audio&#x27;,
        data: {
            type: &#x27;object&#x27;,
            properties: {
                videoId: {
                    type: &#x27;string&#x27;
                },
                videoList: {
                    type: &#x27;list&#x27;
                },
                /**
                * Array of images used in this frame [same as passed to this frame, but
                * may reflect random assignment for this particular participant]
                * @attribute images
                */
                images: {
                    type: &#x27;array&#x27;
                },
                /**
                * ID of image selected at time of proceeding
                * @attribute selectedImage
                */
                selectedImage: {
                    type: &#x27;string&#x27;
                },
                /**
                * Whether image selected at time of proceeding is marked as correct
                * @attribute correctImageSelected
                */
                correctImageSelected: {
                    type: &#x27;string&#x27;
                }
            },
        }
    },

    // Override to do a bit extra when starting recording
    onRecordingStarted() {
        this.startTrial();
        $(&#x27;#waitForVideo&#x27;).hide();
    },

    // Override to do a bit extra when starting session recorder
    onSessionRecordingStarted() {
        this.startTrial();
        $(&#x27;#waitForVideo&#x27;).hide();
    },

    updateCharacterHighlighting() {

        var highlights = this.get(&#x27;highlights&#x27;);

        if (highlights.length) {
            var t = $(&#x27;#player-audio&#x27;)[0].currentTime;
            $(&#x27;.story-image-container img.story-image&#x27;).removeClass(&#x27;narration-highlight&#x27;);
            // var _this = this;
            highlights.forEach(function (h) {
                if (t &gt; h.range[0] &amp;&amp; t &lt; h.range[1]) {
                    var $element = $(&#x27;#&#x27; + h.imageId + &#x27; img.story-image&#x27;)
                    $element.addClass(&#x27;narration-highlight&#x27;);
                    // _this.wiggle($element);
                }
            });
        }
    },

    // Move an image up and down until the isSpeaking class is removed.
    // Yes, this could much more naturally be done by using a CSS animation property
    // on isSpeaking, but despite animations getting applied properly to the element,
    // I haven&#x27;t been able to get that working - because of the possibility of ember-
    // specific problems here, I&#x27;m going with something that *works* even if it&#x27;s less
    // elegent.
    //     wiggle($element) {
    //         var _this = this;
    //         var $parent = $element.parent();
    //         if ($element.hasClass(&#x27;narration-highlight&#x27;)) {
    //             $parent.animate({&#x27;margin-bottom&#x27;: &#x27;.1%&#x27;, &#x27;margin-top&#x27;: &#x27;-.1%&#x27;}, 150, function() {
    //                 if ($element.hasClass(&#x27;narration-highlight&#x27;)) {
    //                     $parent.animate({&#x27;margin-bottom&#x27;: &#x27;0%&#x27;, &#x27;margin-top&#x27;: &#x27;0%&#x27;}, 150, function() {
    //                         _this.wiggle($element);
    //                     });
    //                 }
    //             });
    //         }
    //     },

    replay() {
        // pause any current audio, and set times to 0
        $(&#x27;audio&#x27;).each(function() {
            this.pause();
            this.currentTime = 0;
        });
        /**
         * When main audio segment is replayed
         *
         * @event replayAudio
         */
        this.send(&#x27;setTimeEvent&#x27;, &#x27;replayAudio&#x27;);
        // restart audio
        $(&#x60;.story-image-container&#x60;).hide();
        this.showImages();
        this.playAudio();
    },

    finish() {
        var _this = this;
        /**
         * Trial is complete and attempting to move to next frame; may wait for recording
         * to catch up before proceeding.
         *
         * @event trialComplete
         */
        this.send(&#x27;setTimeEvent&#x27;, &#x27;trialComplete&#x27;);

        if (this.get(&#x27;doRecording&#x27;)) {
            $(&#x27;#nextbutton&#x27;).text(&#x27;Sending recording...&#x27;);
            $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, true);
            this.set(&#x27;nextButtonDisableTimer&#x27;, window.setTimeout(function() {
                $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, false);
            }, 5000));

            this.stopRecorder().then(() =&gt; {
                _this.set(&#x27;stoppedRecording&#x27;, true);
                _this.send(&#x27;next&#x27;);
            }, () =&gt; {
                _this.send(&#x27;next&#x27;);
            });
        } else {
            _this.send(&#x27;next&#x27;);
        }
    },

    finishedAudio() {
        /**
         * When main audio segment finishes playing
         *
         * @event finishAudio
         */
        this.send(&#x27;setTimeEvent&#x27;, &#x27;finishAudio&#x27;);
        this.set(&#x27;finishedAllAudio&#x27;, true);
        this.set(&#x27;canMakeChoice&#x27;, true);
        this.checkAndEnableProceed();
    },

    checkAndEnableProceed() {
        if (this.get(&#x27;minDurationAchieved&#x27;) &amp;&amp; this.get(&#x27;finishedAllAudio&#x27;) &amp;&amp; !this.get(&#x27;showingFeedbackDialog&#x27;) &amp;&amp; ((this.get(&#x27;selectedImage&#x27;) &amp;&amp; (this.get(&#x27;correctImageSelected&#x27;) || !this.get(&#x27;correctChoiceRequired&#x27;))) || !this.get(&#x27;choiceRequired&#x27;))) {
            this.readyToFinish();
        }
    },

    readyToFinish() {
        if (this.get(&#x27;autoProceed&#x27;)) {
            this.send(&#x27;finish&#x27;);
        } else {
            $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, false);
        }
    },

    startTrial() {
        this.set(&#x27;startedTrial&#x27;, true);
        if (this.get(&#x27;durationSeconds&#x27;) &amp;&amp; this.get(&#x27;durationSeconds&#x27;) &gt; 0) {
            let _this = this;
            /**
            * Timer for set-duration trial begins
            *
            * @event startTimer
            */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;startTimer&#x27;);
            this.set(&#x27;pageTimer&#x27;, window.setTimeout(function() {
                /**
                    * Timer for set-duration trial ends
                    *
                    * @event endTimer
                    */
                _this.send(&#x27;setTimeEvent&#x27;, &#x27;endTimer&#x27;);
                _this.set(&#x27;minDurationAchieved&#x27;, true);
                _this.checkAndEnableProceed();
            }, _this.get(&#x27;durationSeconds&#x27;) * 1000));
            if (this.get(&#x27;showProgressBar&#x27;)) {
                let timerStart = new Date().getTime();
                let durationSeconds = _this.get(&#x27;durationSeconds&#x27;);
                this.set(&#x27;progressTimer&#x27;, window.setInterval(function() {
                    let now = new Date().getTime();
                    var prctDone =  (now - timerStart) / (durationSeconds * 10);
                    $(&#x27;.progress-bar&#x27;).css(&#x27;width&#x27;, prctDone + &#x27;%&#x27;);
                }, 100));
            }
        } else {
            this.set(&#x27;minDurationAchieved&#x27;, true);
        }

        this.playAudio();
        this.showImages();
    },

    playAudio() {
        // Start audio if there is any
        var _this = this;
        if ($(&#x27;#player-audio source&#x27;).length) {
            $(&#x27;#player-audio&#x27;)[0].play().then(() =&gt; {
                /**
                 * When main audio segment starts playing
                 *
                 * @event startAudio
                 */
                _this.send(&#x27;setTimeEvent&#x27;, &#x27;startAudio&#x27;);
            }, () =&gt; {
                /**
                 * When main audio cannot be started. In this case we treat it as if
                 * the audio was completed (for purposes of allowing participant to
                 * proceed)
                 *
                 * @event failedToStartAudio
                 */
                _this.send(&#x27;setTimeEvent&#x27;, &#x27;failedToStartAudio&#x27;);
                _this.finishedAudio();
            });
        } else { // Otherwise treat as if completed
            this.finishedAudio();
        }
    },

    showImages() {
        /**
         * When images are displayed to participant (for images without any delay added)
         *
         * @event displayAllImages
         */
        this.send(&#x27;setTimeEvent&#x27;, &#x27;displayImages&#x27;);
        var _this = this;
        $.each(this.get(&#x27;images_parsed&#x27;), function(idx, image) {
            if (image.hasOwnProperty(&#x27;displayDelayMs&#x27;)) {
                var thisTimeout = window.setTimeout(function() {
                    /**
                     * When a specific image is shown at a delay.
                     *
                     * @event displayImage
                     * @param {String} imageId
                     */
                    _this.send(&#x27;setTimeEvent&#x27;, &#x27;displayImage&#x27;, {
                        imageId: image.id
                    });
                    $(&#x60;.story-image-container#${image.id}&#x60;).show();
                }, image.displayDelayMs);
                if (_this.get(&#x27;imageDisplayTimers&#x27;)) {
                    _this.get(&#x27;imageDisplayTimers&#x27;).push(thisTimeout);
                } else {
                    _this.set(&#x27;imageDisplayTimers&#x27;, [thisTimeout]);
                }
            } else {
                $(&#x60;.story-image-container#${image.id}&#x60;).show();
            }
        });
    },

    clickImage(imageId, nonChoiceOption, correct, feedbackText) {
        // If this is a choice frame and a valid choice and we&#x27;re allowed to make a choice yet...
        if (this.get(&#x27;choiceRequired&#x27;) &amp;&amp; !nonChoiceOption &amp;&amp; this.get(&#x27;canMakeChoice&#x27;) &amp;&amp; !this.get(&#x27;showingFeedbackDialog&#x27;)) {
            this.set(&#x27;finishedAllAudio&#x27;, true); // Treat as if audio is finished in case making choice before audio finishes - otherwise we never satisfy that criterion
            /**
             * When one of the image options is clicked during a choice frame
             *
             * @event clickImage
             * @param {String} imageId ID of the image selected
             * @param {Boolean} correct whether this image is marked as correct
             */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;clickImage&#x27;, {
                imageId: imageId,
                correct: correct
            });

            // Highlight the selected image and store it
            $(&#x27;.story-image-container img&#x27;).removeClass(&#x27;highlight&#x27;);
            $(&#x27;#&#x27; + imageId + &#x27; img&#x27;).addClass(&#x27;highlight&#x27;);
            this.set(&#x27;selectedImage&#x27;, imageId);
            this.set(&#x27;correctImageSelected&#x27;, correct);

            if (this.get(&#x27;correctChoiceRequired&#x27;) &amp;&amp; !correct) {
                $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, true);
            }

            var noFeedback = true; // Track whether we&#x27;re giving some form of feedback
            // vs. allowing immediate proceeding

            var _this = this;
            // Play any feedback audio if available
            if ($(&#x60;#${imageId}.story-image-container audio source&#x60;).length) {
                noFeedback = false;
                // If there&#x27;s audio associated with this choice,
                $(&#x27;audio&#x27;).each(function() { // pause any other audio
                    this.pause();
                    this.currentTime = 0;
                });
                $(&#x60;#${imageId}.story-image-container audio&#x60;)[0].play().then(() =&gt; {
                    /**
                     * When image/feedback audio is started
                     *
                     * @event startImageAudio
                     * @param {String} imageId
                     */
                    _this.send(&#x27;setTimeEvent&#x27;, &#x27;startImageAudio&#x27;, {
                        imageId: imageId
                    });
                }, () =&gt; {
                    /**
                     * When image/feedback audio cannot be started. In this case we treat it as if
                     * the audio was completed (for purposes of allowing participant to
                     * proceed)
                     *
                     * @event failedToStartImageAudio
                     * @param {String} imageId
                     */
                    _this.send(&#x27;setTimeEvent&#x27;, &#x27;failedToStartImageAudio&#x27;, {
                        imageId: imageId
                    });
                    _this.endFeedbackAudio(imageId, correct);
                });
            }

            // Also display any feedback text if available
            if (feedbackText) {
                noFeedback = false;
                this.set(&#x27;showingFeedbackDialog&#x27;, true);
                $(&#x60;.${imageId}.modal&#x60;).show();
            }

            // If we&#x27;re giving feedback (audio or text), it will be possible to proceed
            // once any audio finishes and any text is dismissed. Otherwise, just ensure
            // that if we&#x27;re moving on, the answer gets highlighted long enough for
            // the participant to see it!
            if (noFeedback) {
                this.set(&#x27;showChoiceTimer&#x27;, window.setTimeout(function() {
                    window.clearInterval(_this.get(&#x27;showChoiceTimer&#x27;));
                    _this.checkAndEnableProceed();
                }, 150));
            }

        }
    },

    endFeedbackAudio(imageId, correct) {  // eslint-disable-line no-unused-vars
        this.checkAndEnableProceed(); // if correct, move on
    },

    actions: {

        // During playing audio
        updateCharacterHighlighting() {
            this.updateCharacterHighlighting();
        },

        replay() {
            this.replay();
        },

        finish() {
            this.finish();
        },

        finishedAudio() {
            this.finishedAudio();
        },

        clickImage(imageId, nonChoiceOption, correct, feedbackText) {
            this.clickImage(imageId, nonChoiceOption, correct, feedbackText);
        },

        endFeedbackAudio(imageId, correct) {
            this.endFeedbackAudio(imageId, correct);
        },

        hideFeedbackDialog(imageId) {
            $(&#x60;.${imageId}.modal&#x60;).hide();
            this.set(&#x27;showingFeedbackDialog&#x27;, false);
            /**
             * When the participant dismisses a feedback dialogue
             *
             * @event dismissFeedback
             * @param {String} imageId
             */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;dismissFeedback&#x27;, {
                imageId: imageId
            });
            this.checkAndEnableProceed();
        }
    },

    // Supply image IDs if they&#x27;re missing.
    didReceiveAttrs() {
        this._super(...arguments);
        var N = 1;
        var allImageIds =  this.get(&#x27;images&#x27;) ? this.get(&#x27;images&#x27;).map(im =&gt; im.hasOwnProperty(&#x27;id&#x27;) ? im.id : null) : [];
        $.each(this.get(&#x27;images&#x27;), function(idx, image) {
            if (!image.hasOwnProperty(&#x27;id&#x27;)) {
                while (allImageIds.includes(&#x60;image_${N}&#x60;)) {
                    N++;
                }
                image.id = &#x60;image_${N}&#x60;;
            }
            N++;
        });

        this.set(&#x27;canMakeChoice&#x27;, !!this.get(&#x27;canMakeChoiceBeforeAudioFinished&#x27;));
        this.set(&#x27;minDurationAchieved&#x27;, !(this.get(&#x27;durationSeconds&#x27;) &gt; 0));
        this.set(&#x27;showProgressBar&#x27;, this.get(&#x27;showProgressBar&#x27;) &amp;&amp; this.get(&#x27;durationSeconds&#x27;) &gt; 0);
        this.set(&#x27;showReplayButton&#x27;, this.get(&#x27;showReplayButton&#x27;) &amp;&amp; this.get(&#x27;audio&#x27;).length);
    },

    didInsertElement() {

        this._super(...arguments);

        // Apply user-provided CSS to parent text block
        if (Object.keys(this.get(&#x27;parentTextBlock&#x27;)).length) {
            var parentTextBlock = this.get(&#x27;parentTextBlock&#x27;) || {};
            var css = parentTextBlock.css || {};
            $(&#x27;#parenttext&#x27;).css(css);
        } else {
            this.set(&#x27;noParentText&#x27;, true);
            if (this.get(&#x27;autoProceed&#x27;)) {
                this.set(&#x27;noStoryControls&#x27;, true);
            }
        }

        // Apply user-provided CSS to images
        $.each(this.get(&#x27;images_parsed&#x27;), function(idx, image) {
            if (!image.position) {
                $(&#x27;#&#x27; + image.id).css({&#x27;left&#x27;: &#x60;${image.left}%&#x60;, &#x27;width&#x27;: &#x60;${image.width}%&#x60;, &#x27;top&#x27;: &#x60;${image.top}%&#x60;, &#x27;height&#x27;: &#x60;${image.height}%&#x60;});
            }
        });

        // Apply background colors
        if (isColor(this.get(&#x27;backgroundColor&#x27;))) {
            $(&#x27;div.exp-lookit-image-audio&#x27;).css(&#x27;background-color&#x27;, this.get(&#x27;backgroundColor&#x27;));
        } else {
            console.warn(&#x27;Invalid background color provided; not applying.&#x27;);
        }

        if (isColor(this.get(&#x27;pageColor&#x27;))) {
            $(&#x27;div.exp-lookit-image-audio div#image-area&#x27;).css(&#x27;background-color&#x27;, this.get(&#x27;pageColor&#x27;));
        } else {
            console.warn(&#x27;Invalid page color provided; not applying.&#x27;);
        }

        $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, true);
        this.checkAndEnableProceed();
    },

    // Once rendered, hide images and (if not recording) begin trial
    didRender() {
        if (!this.get(&#x27;startedTrial&#x27;)) { // don&#x27;t re-hide/re-start upon e.g. rerender
            $(&#x27;.story-image-container&#x27;).hide();
            // If recording, trial will be started upon recording start. Otherwise...
            if (!this.get(&#x27;doRecording&#x27;) &amp;&amp; !this.get(&#x27;startSessionRecording&#x27;)) {
                this.startTrial();
            }
        }
    },

    willDestroyElement() {
        // Clear any timers that might be active
        window.clearInterval(this.get(&#x27;pageTimer&#x27;));
        window.clearInterval(this.get(&#x27;progressTimer&#x27;));
        window.clearInterval(this.get(&#x27;nextButtonDisableTimer&#x27;));
        window.clearInterval(this.get(&#x27;showChoiceTimer&#x27;));
        $.each(this.get(&#x27;imageDisplayTimers&#x27;), function(idx, timeout) {
            window.clearInterval(timeout);
        });

        this._super(...arguments);
    },


});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
