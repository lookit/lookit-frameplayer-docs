<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/components/exp-frame-base/component.js - ember-lookit-frameplayer</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="https://yui-s.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-5">
            <div id="docs-sidebar" class="sidebar apidocs">
              <h2 style="display:inline;">
              <div>
                <img style="float:right; vertical-align:middle;" src="../assets/css/logo.png" height="70">
                <span>Lookit<br> component<br> docs</span>

                    <p>Version: latest <br>(v1.2.0)</p>
                    <select name="select_version" onchange="location = this.value;">
                        <option value="">--Select different version--</option>
                            <option value="releases/v1.2.0/">v1.2.0</option>
                    </select>
              </div>

              </h2>


              <div id="api-list">
                  <div id="api-tabview">
              
                    <div id="api-tabview-panel">
                        <h2 class="off-left">Collections</h2>
                        <ul id="api-modules" class="apis modules">
                            <li class="module-sidebar-exp-player"><a href="../modules/exp-player.html">exp-player</a></li>
                            <li class="module-sidebar-frames"><a href="../modules/frames.html">frames</a></li>
                            <li class="module-sidebar-mixins"><a href="../modules/mixins.html">mixins</a></li>
                            <li class="module-sidebar-randomizers"><a href="../modules/randomizers.html">randomizers</a></li>
                        </ul>
                        <h2 class="off-left">All elements</h2>
                              <div id="api-tabview-filter">
                      <input type="search" id="api-filter" placeholder="Type to filter">
                    </div>
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/Exp-frame-base.html">Exp-frame-base</a></li>
                            <li><a href="../classes/Exp-frame-select.html">Exp-frame-select</a></li>
                            <li><a href="../classes/Exp-lookit-calibration.html">Exp-lookit-calibration</a></li>
                            <li><a href="../classes/Exp-lookit-change-detection.html">Exp-lookit-change-detection</a></li>
                            <li><a href="../classes/Exp-lookit-composite-video-trial.html">Exp-lookit-composite-video-trial</a></li>
                            <li><a href="../classes/Exp-lookit-dialogue-page.html">Exp-lookit-dialogue-page</a></li>
                            <li><a href="../classes/Exp-lookit-exit-survey.html">Exp-lookit-exit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation.html">Exp-lookit-geometry-alternation</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation-open.html">Exp-lookit-geometry-alternation-open</a></li>
                            <li><a href="../classes/Exp-lookit-images-audio.html">Exp-lookit-images-audio</a></li>
                            <li><a href="../classes/Exp-lookit-instructions.html">Exp-lookit-instructions</a></li>
                            <li><a href="../classes/Exp-lookit-mood-questionnaire.html">Exp-lookit-mood-questionnaire</a></li>
                            <li><a href="../classes/Exp-lookit-observation.html">Exp-lookit-observation</a></li>
                            <li><a href="../classes/Exp-lookit-preferential-looking.html">Exp-lookit-preferential-looking</a></li>
                            <li><a href="../classes/Exp-lookit-stimuli-preview.html">Exp-lookit-stimuli-preview</a></li>
                            <li><a href="../classes/Exp-lookit-story-page.html">Exp-lookit-story-page</a></li>
                            <li><a href="../classes/Exp-lookit-survey.html">Exp-lookit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-text.html">Exp-lookit-text</a></li>
                            <li><a href="../classes/Exp-lookit-video.html">Exp-lookit-video</a></li>
                            <li><a href="../classes/Exp-lookit-video-assent.html">Exp-lookit-video-assent</a></li>
                            <li><a href="../classes/Exp-lookit-video-consent.html">Exp-lookit-video-consent</a></li>
                            <li><a href="../classes/Exp-lookit-webcam-display.html">Exp-lookit-webcam-display</a></li>
                            <li><a href="../classes/Exp-video-config.html">Exp-video-config</a></li>
                            <li><a href="../classes/Exp-video-config-quality.html">Exp-video-config-quality</a></li>
                            <li><a href="../classes/Expand-assets.html">Expand-assets</a></li>
                            <li><a href="../classes/Full-screen.html">Full-screen</a></li>
                            <li><a href="../classes/Media-reload.html">Media-reload</a></li>
                            <li><a href="../classes/Permute.html">Permute</a></li>
                            <li><a href="../classes/Random-parameter-set.html">Random-parameter-set</a></li>
                            <li><a href="../classes/Select.html">Select</a></li>
                            <li><a href="../classes/Session-record.html">Session-record</a></li>
                            <li><a href="../classes/Video-record.html">Video-record</a></li>
                            <li><a href="../classes/video-recorder.html">video-recorder</a></li>
                        </ul>
                    </div>
              
                  </div>
              </div>
            </div>
        </div>
        <div class="yui3-u-4-5">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/components/exp-frame-base/component.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import Ajv from &#x27;ajv&#x27;;

//import config from &#x27;ember-get-config&#x27;;
import FullScreen from &#x27;../../mixins/full-screen&#x27;;
import SessionRecord from &#x27;../../mixins/session-record&#x27;;

/**
 * @module exp-player
 * @submodule frames
 */

/** An abstract component for defining experimenter frames
 *
 * This provides common base behavior required for any experiment frame. All experiment frames must extend this one.
 *
 * This frame has no configuration options because all of its logic is internal, and is almost never directly used
 *   in an experiment. It exports no data. Sample experiment definition usage (provided for completeness):
  &#x60;&#x60;&#x60;json
    &quot;frames&quot;: {
       &quot;my-sample-frame&quot;: {
         &quot;kind&quot;: &quot;exp-base-frame&quot;
       }
    }
 * &#x60;&#x60;&#x60;
 *
 * As a user you will almost never need to insert a component into a template directly- the platform should handle that
 *  by automatically inserting an &lt;a href=&quot;../classes/Exp-player.html&quot; class=&quot;crosslink&quot;&gt;exp-player&lt;/a&gt; component when your experiment starts.
 * However, a sample template usage is provided below for completeness.
 *
 * &#x60;&#x60;&#x60;handlebars
 *  {{
      component currentFrameTemplate
        frameIndex=frameIndex
        frameConfig=currentFrameConfig
        frameContext=currentFrameContext

        session=session
        experiment=experiment

        next=(action &#x27;next&#x27;)
        exit=(action &#x27;exit&#x27;)
        previous=(action &#x27;previous&#x27;)
        saveHandler=(action &#x27;saveFrame&#x27;)
        skipone=(action &#x27;skipone&#x27;)
        extra=extra
    }}
 * &#x60;&#x60;&#x60;
 * @class Exp-frame-base
 *
 * @uses Full-screen
 * @uses Session-record
 */
export default Ember.Component.extend(FullScreen, SessionRecord, {
    toast: Ember.inject.service(),
    // {String} the unique identifier for the _instance_
    id: null,
    kind: null,

    extra: {},

    mergedProperties: [&#x27;frameSchemaProperties&#x27;],
    concatenatedProperties: [&#x27;frameSchemaRequired&#x27;],

    frameSchemaRequired: [],
    frameSchemaProperties: { // Configuration parameters, which can be auto-populated from the experiment structure JSON
    },

    meta: { // Configuration for all fields available on the component/template
        name: &#x27;Base Experimenter Frame&#x27;,
        description: &#x27;The abstract base frame for Experimenter frames.&#x27;,
        data: { // Controls what and how parameters are serialized and sent to the server. Ideally there should be a validation mechanism.
            type: &#x27;object&#x27;,
            properties: {}
        }
    },
    // {Number} the current exp-player frameIndex
    frameIndex: null,
    frameConfig: null,
    frameContext: null,
    frameType: &#x27;DEFAULT&#x27;,
    eventTimings: null,
    _oldFrameIndex: null,

    /**
     * Function to generate additional properties for this frame (like {&quot;kind&quot;: &quot;exp-lookit-text&quot;})
     * at the time the frame is initialized. Allows behavior of study to depend on what has
     * happened so far (e.g., answers on a form or to previous test trials).
     * Must be a valid Javascript function, returning an object, provided as
     * a string.
     *
     *
     * Arguments that will be provided are: &#x60;expData&#x60;, &#x60;sequence&#x60;, &#x60;child&#x60;, &#x60;pastSessions&#x60;, &#x60;conditions&#x60;.
     *
     *
     * &#x60;expData&#x60;, &#x60;sequence&#x60;, and &#x60;conditions&#x60; are the same data as would be found in the session data shown
     * on the Lookit experimenter interface under &#x27;Individual Responses&#x27;, except that
     * they will only contain information up to this point in the study.
     *
     *
     * &#x60;expData&#x60; is an object consisting of &#x60;frameId&#x60;: &#x60;frameData&#x60; pairs; the data associated
     * with a particular frame depends on the frame kind.
     *
     *
     * &#x60;sequence&#x60; is an ordered list of frameIds, corresponding to the keys in &#x60;expData&#x60;.
     *
     *
     * &#x60;conditions&#x60; is an object representing the data stored by any randomizer frames;
     * keys are &#x60;frameId&#x60;s for randomizer frames and data stored depends on the randomizer
     * used.
     *
     *
     * &#x60;child&#x60; is an object that has the following properties - use child.get(propertyName)
     * to access:
     * - &#x60;additionalInformation&#x60;: String; additional information field from child form
     * - &#x60;ageAtBirth&#x60;: String; child&#x27;s gestational age at birth in weeks. Possible values are
     *   &quot;24&quot; through &quot;39&quot;, &quot;na&quot; (not sure or prefer not to answer),
     * &quot;&lt;24&quot; (under 24 weeks), and &quot;40&gt;&quot; (40 or more weeks).
     * - &#x60;birthday&#x60;: timestamp in format &quot;Mon Apr 10 2017 20:00:00 GMT-0400 (Eastern Daylight Time)&quot;
     * - &#x60;gender&#x60;: &quot;f&quot; (female), &quot;m&quot; (male), &quot;o&quot; (other), or &quot;na&quot; (prefer not to answer)
     * - &#x60;givenName&#x60;: String, child&#x27;s given name/nickname
     * - &#x60;id&#x60;: String, child UUID
     *
     *
     * &#x60;pastSessions&#x60; is a list of previous response objects for this child and this study,
     * ordered starting from most recent (at index 0 is this session!). Each has properties
     * (access as pastSessions[i].get(propertyName)):
     * - &#x60;completed&#x60;: Boolean, whether they submitted an exit survey
     * - &#x60;completedConsentFrame&#x60;: Boolean, whether they got through at least a consent frame
     * - &#x60;conditions&#x60;: Object representing any conditions assigned by randomizer frames
     * - &#x60;createdOn&#x60;: timestamp in format &quot;Thu Apr 18 2019 12:33:26 GMT-0400 (Eastern Daylight Time)&quot;
     * - &#x60;expData&#x60;: Object consisting of frameId: frameData pairs
     * - &#x60;globalEventTimings&#x60;: list of any events stored outside of individual frames - currently
     *   just used for attempts to leave the study early
     * - &#x60;sequence&#x60;: ordered list of frameIds, corresponding to keys in expData
     *
     *
     * Example:
     * &#x60;&#x60;&#x60;
     * function(expData, sequence, child, pastSessions, conditions) {
     *     return {
     *        &#x27;blocks&#x27;:
     *             [
     *                 {
     *                     &#x27;text&#x27;: &#x27;Name: &#x27; + child.get(&#x27;givenName&#x27;)
     *                 },
     *                 {
     *                     &#x27;text&#x27;: &#x27;Frame number: &#x27; + sequence.length
     *                 },
     *                 {
     *                     &#x27;text&#x27;: &#x27;N past sessions: &#x27; + pastSessions.length
     *                 }
     *             ]
     *       };
     *   }
     * &#x60;&#x60;&#x60;
     *
     *
     *  (This example is split across lines for readability; when added to JSON it would need
     *  to be on one line.)
     *
     * @property {String} generateProperties
     * @default null
     */
    generateProperties: null,
    generatedProperties: null,
    _generatePropertiesFn: null,

    /**
     * Function to select which frame index to go to when using the &#x27;next&#x27; action on this
     * frame. Allows flexible looping / short-circuiting based on what has happened so far
     * in the study (e.g., once the child answers N questions correctly, move on to next
     * segment). Must be a valid Javascript function, returning a number from 0 through
     * frames.length - 1, provided as a string.
     *
     *
     * Arguments that will be provided are:
     * &#x60;frames&#x60;, &#x60;frameIndex&#x60;, &#x60;expData&#x60;, &#x60;sequence&#x60;, &#x60;child&#x60;, &#x60;pastSessions&#x60;
     *
     *
     * &#x60;frames&#x60; is an ordered list of frame configurations for this study; each element
     * is an object corresponding directly to a frame you defined in the
     * JSON document for this study (but with any randomizer frames resolved into the
     * particular frames that will be used this time).
     *
     *
     * &#x60;frameIndex&#x60; is the index in &#x60;frames&#x60; of the current frame
     *
     *
     * &#x60;expData&#x60; is an object consisting of &#x60;frameId&#x60;: &#x60;frameData&#x60; pairs; the data associated
     * with a particular frame depends on the frame kind.
     *
     *
     * &#x60;sequence&#x60; is an ordered list of frameIds, corresponding to the keys in &#x60;expData&#x60;.
     *
     *
     * &#x60;child&#x60; is an object that has the following properties - use child.get(propertyName)
     * to access:
     * - &#x60;additionalInformation&#x60;: String; additional information field from child form
     * - &#x60;ageAtBirth&#x60;: String; child&#x27;s gestational age at birth in weeks. Possible values are
     *   &quot;24&quot; through &quot;39&quot;, &quot;na&quot; (not sure or prefer not to answer),
     * &quot;&lt;24&quot; (under 24 weeks), and &quot;40&gt;&quot; (40 or more weeks).
     * - &#x60;birthday&#x60;: timestamp in format &quot;Mon Apr 10 2017 20:00:00 GMT-0400 (Eastern Daylight Time)&quot;
     * - &#x60;gender&#x60;: &quot;f&quot; (female), &quot;m&quot; (male), &quot;o&quot; (other), or &quot;na&quot; (prefer not to answer)
     * - &#x60;givenName&#x60;: String, child&#x27;s given name/nickname
     * - &#x60;id&#x60;: String, child UUID
     *
     *
     * &#x60;pastSessions&#x60; is a list of previous response objects for this child and this study,
     * ordered starting from most recent (at index 0 is this session!). Each has properties
     * (access as pastSessions[i].get(propertyName)):
     * - &#x60;completed&#x60;: Boolean, whether they submitted an exit survey
     * - &#x60;completedConsentFrame&#x60;: Boolean, whether they got through at least a consent frame
     * - &#x60;conditions&#x60;: Object representing any conditions assigned by randomizer frames
     * - &#x60;createdOn&#x60;: timestamp in format &quot;Thu Apr 18 2019 12:33:26 GMT-0400 (Eastern Daylight Time)&quot;
     * - &#x60;expData&#x60;: Object consisting of frameId: frameData pairs
     * - &#x60;globalEventTimings&#x60;: list of any events stored outside of individual frames - currently
     *   just used for attempts to leave the study early
     * - &#x60;sequence&#x60;: ordered list of frameIds, corresponding to keys in expData
     *
     *
     * Example that just sends us to the last frame of the study no matter what:
     * &#x60;&#x60;&quot;function(frames, frameIndex, frameData, expData, sequence, child, pastSessions) {return frames.length - 1;}&quot;&#x60;&#x60;&#x60;
     *
     *
     * @property {String} selectNextFrame
     * @default null
     */
    selectNextFrame: null,
    _selectNextFrameFn: null,

    /**
     * An object containing values for any parameters (variables) to use in this frame.
     * Any property VALUES in this frame that match any of the property NAMES in &#x60;parameters&#x60;
     * will be replaced by the corresponding parameter value. For example, suppose your frame
     * is:
     *
&#x60;&#x60;&#x60;
{
    &#x27;kind&#x27;: &#x27;FRAME_KIND&#x27;,
    &#x27;parameters&#x27;: {
        &#x27;FRAME_KIND&#x27;: &#x27;exp-lookit-text&#x27;
    }
}
&#x60;&#x60;&#x60;
     *
     * Then the frame &#x60;kind&#x60; will be &#x60;exp-lookit-text&#x60;. This may be useful if you need
     * to repeat values for different frame properties, especially if your frame is actually
     * a randomizer or group. You may use parameters nested within objects (at any depth) or
     * within lists.
     *
     * You can also use selectors to randomly sample from or permute
     * a list defined in &#x60;parameters&#x60;. Suppose &#x60;STIMLIST&#x60; is defined in
     * &#x60;parameters&#x60;, e.g. a list of potential stimuli. Rather than just using &#x60;STIMLIST&#x60;
     * as a value in your frames, you can also:
     *
     * * Select the Nth element (0-indexed) of the value of &#x60;STIMLIST&#x60;: (Will cause error if &#x60;N &gt;= THELIST.length&#x60;)
&#x60;&#x60;&#x60;
    &#x27;parameterName&#x27;: &#x27;STIMLIST#N&#x27;
&#x60;&#x60;&#x60;
     * * Select (uniformly) a random element of the value of &#x60;STIMLIST&#x60;:
&#x60;&#x60;&#x60;
    &#x27;parameterName&#x27;: &#x27;STIMLIST#RAND&#x27;
&#x60;&#x60;&#x60;
    * * Set &#x60;parameterName&#x60; to a random permutation of the value of &#x60;STIMLIST&#x60;:
&#x60;&#x60;&#x60;
    &#x27;parameterName&#x27;: &#x27;STIMLIST#PERM&#x27;
&#x60;&#x60;&#x60;
    * * Select the next element in a random permutation of the value of &#x60;STIMLIST&#x60;, which is used across all
    * substitutions in this randomizer. This allows you, for instance, to provide a list
    * of possible images in your &#x60;parameterSet&#x60;, and use a different one each frame with the
    * subset/order randomized per participant. If more &#x60;STIMLIST#UNIQ&#x60; parameters than
    * elements of &#x60;STIMLIST&#x60; are used, we loop back around to the start of the permutation
    * generated for this randomizer.
&#x60;&#x60;&#x60;
    &#x27;parameterName&#x27;: &#x27;STIMLIST#UNIQ&#x27;
&#x60;&#x60;&#x60;
     *
     * @property {Object[]} parameters
     * @default {}
     */
    parameters: {},

    session: null,

    // see https://github.com/emberjs/ember.js/issues/3908. Moved
    // to init because we were losing the first event per instance of a frame
    // when it was in didReceiveAttrs.
    setTimings: Ember.on(&#x27;init&#x27;, function () {
        this.set(&#x27;eventTimings&#x27;, []);
    }),

    loadData: function (frameData) { // eslint-disable-line no-unused-vars
        return null;
    },

    didReceiveAttrs: function () {
        this._super(...arguments);

        if (!this.get(&#x27;frameConfig&#x27;)) {
            return;
        }

        let currentFrameIndex = this.get(&#x27;frameIndex&#x27;, null);

        let clean = currentFrameIndex !== this.get(&#x27;_oldFrameIndex&#x27;);

        var defaultParams = this.setupParams(clean);
        if (clean) {
            Object.keys(defaultParams).forEach((key) =&gt; {
                this.set(key, defaultParams[key]);
            });
        }

        if (!this.get(&#x27;id&#x27;)) {
            var frameIndex = this.get(&#x27;frameIndex&#x27;);
            var kind = this.get(&#x27;kind&#x27;);
            this.set(&#x27;id&#x27;, &#x60;${kind}-${frameIndex}&#x60;);
        }

        if (clean) {
            var session = this.get(&#x27;session&#x27;);
            var expData = session ? session.get(&#x27;expData&#x27;) : null;

            // Load any existing data for this particular frame - e.g. for a survey that
            // the participant is returning to via a previous button.
            if (session &amp;&amp; session.get(&#x27;expData&#x27;)) {
                var key = this.get(&#x27;frameIndex&#x27;) + &#x27;-&#x27; + this.get(&#x27;id&#x27;);
                if (expData[key]) {
                    this.loadData(expData[key]);
                }
            }

            // Use the provided generateProperties fn, if any, to generate properties for this
            // frame on-the-fly based on expData, sequence, child, &amp; pastSessions.
            if (this.get(&#x27;generateProperties&#x27;)) { // Only if generateProperties is non-empty
                try {
                    this.set(&#x27;_generatePropertiesFn&#x27;, Function(&#x27;return &#x27; + this.get(&#x27;generateProperties&#x27;))());
                } catch (error) {
                    console.error(error);
                    throw new Error(&#x27;generateProperties provided for this frame, but cannot be evaluated.&#x27;);
                }
                if (typeof (this.get(&#x27;_generatePropertiesFn&#x27;)) === &#x27;function&#x27;) {
                    var sequence = session ? session.get(&#x27;sequence&#x27;, null) : null;
                    var child = session ? session.get(&#x27;child&#x27;, null) : null;
                    var conditions = session ? session.get(&#x27;conditions&#x27;, {}) : {};
                    var frameContext = this.get(&#x27;frameContext&#x27;);
                    var pastSessions = frameContext ? frameContext.pastSessions : null;
                    var generatedParams = this._generatePropertiesFn(expData, sequence, child, pastSessions, conditions);
                    if (typeof (generatedParams) === &#x27;object&#x27;) {
                        this.set(&#x27;generatedProperties&#x27;, generatedParams);
                        Object.keys(generatedParams).forEach((key) =&gt; {
                            this.set(key, generatedParams[key]);
                        });
                    } else {
                        throw new Error(&#x27;generateProperties function provided for this frame, but did not return an object&#x27;);
                    }
                } else {
                    throw new Error(&#x27;generateProperties provided for this frame, but does not evaluate to a function&#x27;);
                }
            }

            // Use the provided selectNextFrame fn, if any, to determine which frame should come
            // next.
            if (this.get(&#x27;selectNextFrame&#x27;)) { // Only if selectNextFrame is non-empty
                try {
                    this.set(&#x27;_selectNextFrameFn&#x27;, Function(&#x27;return &#x27; + this.get(&#x27;selectNextFrame&#x27;))());
                } catch (error) {
                    console.error(error);
                    throw new Error(&#x27;selectNextFrame provided for this frame, but cannot be evaluated.&#x27;);
                }
                if (!(typeof (this.get(&#x27;_selectNextFrameFn&#x27;)) === &#x27;function&#x27;)) {
                    throw new Error(&#x27;selectNextFrame provided for this frame, but does not evaluate to a function&#x27;);
                }
            }

            // After adding any generated properties, check that all required fields are set
            if (this.get(&#x27;frameSchemaProperties&#x27;).hasOwnProperty(&#x27;required&#x27;)) {
                var requiredFields = this.get(&#x27;frameSchemaProperties.required&#x27;, []);
                requiredFields.forEach((key) =&gt; {
                    if (!this.hasOwnProperty(key) || this.get(key) === undefined) {
                        // Don&#x27;t actually throw an error here because the frame may actually still function and that&#x27;s probably good
                        console.error(&#x60;Missing required parameter &#x27;${key}&#x27; for frame of kind &#x27;${this.get(&#x27;kind&#x27;)}&#x27;.&#x60;);
                    }
                });
            }

            // Use JSON schema validator to check that all values are within specified constraints
            var ajv = new Ajv({
                allErrors: true,
                verbose: true
            });
            var frameSchema = {type: &#x27;object&#x27;, properties: this.get(&#x27;frameSchemaProperties&#x27;)};
            try {
                var validate = ajv.compile(frameSchema);
                var valid = validate(this);
                if (!valid) {
                    console.warn(&#x27;Invalid: &#x27; + ajv.errorsText(validate.errors));
                }
            }
            catch (error) {
                console.error(&#x60;Failed to compile frameSchemaProperties to use for validating researcher usage of frame type &#x27;${this.get(&#x27;kind&#x27;)}.&#x60;);
            }

        }

        this.set(&#x27;_oldFrameIndex&#x27;, currentFrameIndex);
    },

    // Internal save logic
    _save() {
        var frameId = &#x60;${this.get(&#x27;id&#x27;)}&#x60;;  // don&#x27;t prepend frameindex, done by parser
        // When exiting frame, save the data to the base player using the provided saveHandler
        const payload = this.serializeContent();
        return this.attrs.saveHandler(frameId, payload);
    },

    // Display error messages related to save failures
    displayError(error) { // eslint-disable-line no-unused-vars
        // If the save failure was a server error, warn the user. This error should never disappear.
        // Note: errors are not visible in FS mode, which is generally the desired behavior so as not to silently
        // bias infant looking time towards right.
        const msg = &#x27;Check your internet connection. If another error like this still shows up as you continue, please contact lookit-tech@mit.edu to let us know!&#x27;;
        this.get(&#x27;toast&#x27;).error(msg, &#x27;Error: Could not save data&#x27;, {timeOut: 0, extendedTimeOut: 0});
    },

    setupParams(clean) {
        // Add config properties and data to be serialized as instance parameters (overriding with values explicitly passed in)
        var params = this.get(&#x27;frameConfig&#x27;);

        var defaultParams = {};
        Object.keys(this.get(&#x27;frameSchemaProperties&#x27;) || {}).forEach((key) =&gt; {
            defaultParams[key] = this.get(&#x60;frameSchemaProperties.${key}.default&#x60;);
        });

        Object.keys(this.get(&#x27;meta.data&#x27;).properties || {}).forEach((key) =&gt; {
            if (this[key] &amp;&amp; this[key].isDescriptor) {
                return;
            }
            var value = !clean ? this.get(key) : undefined;
            if (typeof value === &#x27;undefined&#x27;) {
                // Make deep copy of the default value (to avoid subtle reference errors from reusing mutable containers)
                defaultParams[key] = Ember.copy(this.get(&#x60;frameSchemaProperties.${key}.default&#x60;), true);
            } else {
                defaultParams[key] = value;
            }
        });

        // Need to explicitly set defaults for non-meta properties here, otherwise defaults
        // do not overwrite previous properties when no value is provided on the next
        // frame.
        defaultParams.generateProperties = null;
        defaultParams.generatedProperties = null;
        defaultParams.selectNextFrame = null;
        Ember.assign(defaultParams, params);

        return defaultParams;
    },

    /**
     * Any properties generated via a custom generateProperties function provided to this
     * frame (e.g., a score you computed to decide on feedback). In general will be null.
     * @attribute generatedProperties
     */

    /**
     * Type of frame: EXIT (exit survey), CONSENT (consent or assent frame), or DEFAULT
     * (anything else)
     * @attribute frameType
     */

    /**
     * Ordered list of events captured during this frame (oldest to newest). Each event is
     * represented as an object with at least the properties
     * &#x60;{&#x27;eventType&#x27;: EVENTNAME, &#x27;timestamp&#x27;: TIMESTAMP}&#x60;.
     * See Events tab for details of events that might be captured.
     * @attribute eventTimings
     */

    /**
     * Each frame that extends ExpFrameBase will send at least an array &#x60;eventTimings&#x60;,
     * a frame type, and any generateProperties back to the server upon completion.
     * Individual frames may define additional properties that are sent.
     *
     * @param {Array} eventTimings
     * @method serializeContent
     * @return {Object}
     */
    serializeContent() {
        // Serialize selected parameters for this frame, plus eventTiming data
        var serialized = this.getProperties(Object.keys(this.get(&#x27;meta.data.properties&#x27;) || {}));
        serialized.generatedProperties = this.get(&#x27;generatedProperties&#x27;);
        serialized.eventTimings = this.get(&#x27;eventTimings&#x27;);
        serialized.frameType = this.get(&#x27;frameType&#x27;);
        return serialized;
    },

    /**
     * Create the time event payload for a particular frame / event. This can be overridden to add fields to every
     *  event sent by a particular frame
     * @method makeTimeEvent
     * @param {String} eventName
     * @param {Object} [extra] An object with additional properties to be sent to the server
     * @return {Object} Event type, time, and any additional metadata provided
     */
    makeTimeEvent(eventName, extra) {
        const curTime = new Date();
        const eventData = {
            eventType: &#x60;${this.get(&#x27;kind&#x27;, &#x27;unknown-frame&#x27;)}:${eventName}&#x60;,
            timestamp: curTime.toISOString()
        };
        Ember.assign(eventData, extra);
        // Add some extra info if there&#x27;s session recording ongoing
        if (this.get(&#x27;sessionRecorder&#x27;) &amp;&amp; this.get(&#x27;sessionRecordingInProgress&#x27;)) {
            Ember.assign(eventData, {
                sessionStreamTime: this.get(&#x27;sessionRecorder&#x27;).getTime()
            });
        }
        return eventData;

    },

    setSessionCompleted() {
        this.get(&#x27;session&#x27;).set(&#x27;completed&#x27;, true);
    },

    actions: {
        setTimeEvent(eventName, extra) {
            let eventData = this.makeTimeEvent(eventName, extra);
            console.log(&#x60;Timing event captured for ${eventName}&#x60;, eventData);
            // Copy timing event into a single dict for this component instance
            let timings = this.get(&#x27;eventTimings&#x27;);
            timings.push(eventData);
            this.set(&#x27;eventTimings&#x27;, timings);
        },

        save() {
            // Show an error if saving fails
            this._save().catch(err =&gt; this.displayError(err));
        },

        next() {
            /**
             * Move to next frame
             *
             * @event nextFrame
             */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;nextFrame&#x27;);

            // Determine which frame to go to next
            var iNextFrame = -1;
            if (this._selectNextFrameFn) {
                var session = this.get(&#x27;session&#x27;);
                var expData = session ? session.get(&#x27;expData&#x27;) : null;
                var sequence = session ? session.get(&#x27;sequence&#x27;, null) : null;
                var child = session ? session.get(&#x27;child&#x27;, null) : null;
                var frameContext = this.get(&#x27;frameContext&#x27;);
                var pastSessions = frameContext ? frameContext.pastSessions : null;
                var frames = this.get(&#x27;parentView&#x27;).get(&#x27;frames&#x27;);
                var frameIndex = this.get(&#x27;frameIndex&#x27;);
                var frameData = this.serializeContent(); // note - may not have saved to expData yet at time of call

                iNextFrame = this._selectNextFrameFn(frames, frameIndex, frameData, expData, sequence, child, pastSessions);
                if (!(typeof (iNextFrame) === &#x27;number&#x27;)) {
                    throw new Error(&#x27;selectNextFrame function provided for this frame, but did not return a number&#x27;);
                }
            }

            // Note: this will allow participant to proceed even if saving fails. The
            // reason not to execute &#x27;next&#x27; within this._save().then() is that an action
            // executed as a promise doesn&#x27;t count as a &#x27;user interaction&#x27; event, so
            // we wouldn&#x27;t be able to enter FS mode upon starting the next frame. Given
            // that the user is likely to have limited ability to FIX a save error, and the
            // only thing they&#x27;ll really be able to do is try again anyway, preventing
            // them from continuing is unnecessarily disruptive.
            this.send(&#x27;save&#x27;);

            if (this.get(&#x27;endSessionRecording&#x27;) &amp;&amp; this.get(&#x27;sessionRecorder&#x27;)) {
                this.get(&#x27;session&#x27;).set(&#x27;recordingInProgress&#x27;, false);
                var _this = this;
                this.stopSessionRecorder().finally(() =&gt; {
                    _this.sendAction(&#x27;next&#x27;, iNextFrame);
                    window.scrollTo(0, 0);
                    _this.destroySessionRecorder();
                });
            } else {
                this.sendAction(&#x27;next&#x27;, iNextFrame);
                window.scrollTo(0, 0);
            }

        },

        exit() {
            this.sendAction(&#x27;exit&#x27;);
        },

        previous() {
            /**
             * Move to previous frame
             *
             * @event previousFrame
             */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;previousFrame&#x27;);
            var frameId = &#x60;${this.get(&#x27;id&#x27;)}&#x60;; // don&#x27;t prepend frameindex, done by parser
            console.log(&#x60;Previous: Leaving frame ID ${frameId}&#x60;);
            this.sendAction(&#x27;previous&#x27;);
            window.scrollTo(0, 0);
        }
    },

    didInsertElement() {
        // Add different classes depending on whether fullscreen mode is
        // being triggered as part of standard frame operation or as an override to a frame
        // that is not typically fullscreen. In latter case, keep formatting as close to
        // before as possible, to enable forms etc. to work ok in fullscreen mode.
        Ember.$(&#x27;*&#x27;).removeClass(&#x27;player-fullscreen&#x27;);
        Ember.$(&#x27;*&#x27;).removeClass(&#x27;player-fullscreen-override&#x27;);
        Ember.$(&#x27;#application-parse-error-text&#x27;).hide();
        var $element = Ember.$(&#x60;#${this.get(&#x27;fullScreenElementId&#x27;)}&#x60;);
        if (this.get(&#x27;displayFullscreenOverride&#x27;) &amp;&amp; !this.get(&#x27;displayFullscreen&#x27;)) {
            $element.addClass(&#x27;player-fullscreen-override&#x27;);
        } else {
            $element.addClass(&#x27;player-fullscreen&#x27;);
        }
        // Set to non-fullscreen (or FS if overriding) immediately, except for frames displayed fullscreen.
        // Note: if this is defined the same way in full-screen.js, it gets called twice
        // for reasons I don&#x27;t yet understand.
        if (this.get(&#x27;displayFullscreenOverride&#x27;) || this.get(&#x27;displayFullscreen&#x27;)) {
            this.send(&#x27;showFullscreen&#x27;);
        } else {
            this.send(&#x27;exitFullscreen&#x27;);
        }
        this._super(...arguments);
    }
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
